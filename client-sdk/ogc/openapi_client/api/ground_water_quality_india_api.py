# coding: utf-8

"""
    OGC Compliant DX Resource Server

    OGC compliant Features and Common API definitions. Includes Schema and Response Objects.   <a href='/stac/api'>STAC API Documentation</a>    <a href='/metering/api'>DX Metering API Documentation</a>

    The version of the OpenAPI document: 1.0.1
    Contact: info@iudx.org.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.collection import Collection
from openapi_client.models.feature_collection_geo_json import FeatureCollectionGeoJSON
from openapi_client.models.feature_geo_json import FeatureGeoJSON

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class GroundWaterQualityIndiaApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_features(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        s__n_: Optional[StrictInt] = None,
        sampling_date: Optional[StrictStr] = None,
        sulphide: Optional[Union[StrictFloat, StrictInt]] = None,
        phenol_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        camg_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        hydroxyl: Optional[StrictInt] = None,
        site_name: Optional[StrictStr] = None,
        nacl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        chlorophyll_a: Optional[StrictStr] = None,
        village_na: Optional[StrictStr] = None,
        depth_of_w: Optional[Union[StrictFloat, StrictInt]] = None,
        carbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        state_ut: Optional[StrictStr] = None,
        bod: Optional[StrictStr] = None,
        mg: Optional[Union[StrictFloat, StrictInt]] = None,
        tehsil: Optional[StrictStr] = None,
        ec: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_cation: Optional[Union[StrictFloat, StrictInt]] = None,
        rsc: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate_cl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        bicarbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        block: Optional[StrictStr] = None,
        fluoride: Optional[Union[StrictFloat, StrictInt]] = None,
        na: Optional[Union[StrictFloat, StrictInt]] = None,
        tss: Optional[StrictInt] = None,
        silica: Optional[StrictStr] = None,
        percent_error: Optional[Union[StrictFloat, StrictInt]] = None,
        sulphate: Optional[Union[StrictFloat, StrictInt]] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        b: Optional[StrictStr] = None,
        tot_anion: Optional[Union[StrictFloat, StrictInt]] = None,
        sar: Optional[Union[StrictFloat, StrictInt]] = None,
        well_site: Optional[StrictStr] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        k: Optional[Union[StrictFloat, StrictInt]] = None,
        district: Optional[StrictStr] = None,
        tot_fe: Optional[Union[StrictFloat, StrictInt]] = None,
        aquifer: Optional[StrictStr] = None,
        nitrate_nitrite: Optional[Union[StrictFloat, StrictInt]] = None,
        ca: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_coliform: Optional[StrictStr] = None,
        tds: Optional[Union[StrictFloat, StrictInt]] = None,
        ammonia: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        phosphate: Optional[Union[StrictFloat, StrictInt]] = None,
        th: Optional[Union[StrictFloat, StrictInt]] = None,
        percent_na: Optional[Union[StrictFloat, StrictInt]] = None,
        ph: Optional[Union[StrictFloat, StrictInt]] = None,
        turbidity: Optional[Union[StrictFloat, StrictInt]] = None,
        chloride: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureCollectionGeoJSON:
        """Get features from Point location of well with the ground water quality related attributes


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param s__n_:
        :type s__n_: int
        :param sampling_date:
        :type sampling_date: str
        :param sulphide:
        :type sulphide: float
        :param phenol_alkalinity:
        :type phenol_alkalinity: float
        :param camg_ratio:
        :type camg_ratio: float
        :param hydroxyl:
        :type hydroxyl: int
        :param site_name:
        :type site_name: str
        :param nacl_ratio:
        :type nacl_ratio: float
        :param chlorophyll_a:
        :type chlorophyll_a: str
        :param village_na:
        :type village_na: str
        :param depth_of_w:
        :type depth_of_w: float
        :param carbonate:
        :type carbonate: float
        :param state_ut:
        :type state_ut: str
        :param bod:
        :type bod: str
        :param mg:
        :type mg: float
        :param tehsil:
        :type tehsil: str
        :param ec:
        :type ec: float
        :param tot_cation:
        :type tot_cation: float
        :param rsc:
        :type rsc: float
        :param nitrate:
        :type nitrate: float
        :param nitrate_cl_ratio:
        :type nitrate_cl_ratio: float
        :param bicarbonate:
        :type bicarbonate: float
        :param block:
        :type block: str
        :param fluoride:
        :type fluoride: float
        :param na:
        :type na: float
        :param tss:
        :type tss: int
        :param silica:
        :type silica: str
        :param percent_error:
        :type percent_error: float
        :param sulphate:
        :type sulphate: float
        :param latitude:
        :type latitude: float
        :param b:
        :type b: str
        :param tot_anion:
        :type tot_anion: float
        :param sar:
        :type sar: float
        :param well_site:
        :type well_site: str
        :param longitude:
        :type longitude: float
        :param k:
        :type k: float
        :param district:
        :type district: str
        :param tot_fe:
        :type tot_fe: float
        :param aquifer:
        :type aquifer: str
        :param nitrate_nitrite:
        :type nitrate_nitrite: float
        :param ca:
        :type ca: float
        :param tot_alkalinity:
        :type tot_alkalinity: float
        :param tot_coliform:
        :type tot_coliform: str
        :param tds:
        :type tds: float
        :param ammonia:
        :type ammonia: str
        :param site_id:
        :type site_id: str
        :param phosphate:
        :type phosphate: float
        :param th:
        :type th: float
        :param percent_na:
        :type percent_na: float
        :param ph:
        :type ph: float
        :param turbidity:
        :type turbidity: float
        :param chloride:
        :type chloride: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            s__n_=s__n_,
            sampling_date=sampling_date,
            sulphide=sulphide,
            phenol_alkalinity=phenol_alkalinity,
            camg_ratio=camg_ratio,
            hydroxyl=hydroxyl,
            site_name=site_name,
            nacl_ratio=nacl_ratio,
            chlorophyll_a=chlorophyll_a,
            village_na=village_na,
            depth_of_w=depth_of_w,
            carbonate=carbonate,
            state_ut=state_ut,
            bod=bod,
            mg=mg,
            tehsil=tehsil,
            ec=ec,
            tot_cation=tot_cation,
            rsc=rsc,
            nitrate=nitrate,
            nitrate_cl_ratio=nitrate_cl_ratio,
            bicarbonate=bicarbonate,
            block=block,
            fluoride=fluoride,
            na=na,
            tss=tss,
            silica=silica,
            percent_error=percent_error,
            sulphate=sulphate,
            latitude=latitude,
            b=b,
            tot_anion=tot_anion,
            sar=sar,
            well_site=well_site,
            longitude=longitude,
            k=k,
            district=district,
            tot_fe=tot_fe,
            aquifer=aquifer,
            nitrate_nitrite=nitrate_nitrite,
            ca=ca,
            tot_alkalinity=tot_alkalinity,
            tot_coliform=tot_coliform,
            tds=tds,
            ammonia=ammonia,
            site_id=site_id,
            phosphate=phosphate,
            th=th,
            percent_na=percent_na,
            ph=ph,
            turbidity=turbidity,
            chloride=chloride,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_features_with_http_info(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        s__n_: Optional[StrictInt] = None,
        sampling_date: Optional[StrictStr] = None,
        sulphide: Optional[Union[StrictFloat, StrictInt]] = None,
        phenol_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        camg_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        hydroxyl: Optional[StrictInt] = None,
        site_name: Optional[StrictStr] = None,
        nacl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        chlorophyll_a: Optional[StrictStr] = None,
        village_na: Optional[StrictStr] = None,
        depth_of_w: Optional[Union[StrictFloat, StrictInt]] = None,
        carbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        state_ut: Optional[StrictStr] = None,
        bod: Optional[StrictStr] = None,
        mg: Optional[Union[StrictFloat, StrictInt]] = None,
        tehsil: Optional[StrictStr] = None,
        ec: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_cation: Optional[Union[StrictFloat, StrictInt]] = None,
        rsc: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate_cl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        bicarbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        block: Optional[StrictStr] = None,
        fluoride: Optional[Union[StrictFloat, StrictInt]] = None,
        na: Optional[Union[StrictFloat, StrictInt]] = None,
        tss: Optional[StrictInt] = None,
        silica: Optional[StrictStr] = None,
        percent_error: Optional[Union[StrictFloat, StrictInt]] = None,
        sulphate: Optional[Union[StrictFloat, StrictInt]] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        b: Optional[StrictStr] = None,
        tot_anion: Optional[Union[StrictFloat, StrictInt]] = None,
        sar: Optional[Union[StrictFloat, StrictInt]] = None,
        well_site: Optional[StrictStr] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        k: Optional[Union[StrictFloat, StrictInt]] = None,
        district: Optional[StrictStr] = None,
        tot_fe: Optional[Union[StrictFloat, StrictInt]] = None,
        aquifer: Optional[StrictStr] = None,
        nitrate_nitrite: Optional[Union[StrictFloat, StrictInt]] = None,
        ca: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_coliform: Optional[StrictStr] = None,
        tds: Optional[Union[StrictFloat, StrictInt]] = None,
        ammonia: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        phosphate: Optional[Union[StrictFloat, StrictInt]] = None,
        th: Optional[Union[StrictFloat, StrictInt]] = None,
        percent_na: Optional[Union[StrictFloat, StrictInt]] = None,
        ph: Optional[Union[StrictFloat, StrictInt]] = None,
        turbidity: Optional[Union[StrictFloat, StrictInt]] = None,
        chloride: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureCollectionGeoJSON]:
        """Get features from Point location of well with the ground water quality related attributes


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param s__n_:
        :type s__n_: int
        :param sampling_date:
        :type sampling_date: str
        :param sulphide:
        :type sulphide: float
        :param phenol_alkalinity:
        :type phenol_alkalinity: float
        :param camg_ratio:
        :type camg_ratio: float
        :param hydroxyl:
        :type hydroxyl: int
        :param site_name:
        :type site_name: str
        :param nacl_ratio:
        :type nacl_ratio: float
        :param chlorophyll_a:
        :type chlorophyll_a: str
        :param village_na:
        :type village_na: str
        :param depth_of_w:
        :type depth_of_w: float
        :param carbonate:
        :type carbonate: float
        :param state_ut:
        :type state_ut: str
        :param bod:
        :type bod: str
        :param mg:
        :type mg: float
        :param tehsil:
        :type tehsil: str
        :param ec:
        :type ec: float
        :param tot_cation:
        :type tot_cation: float
        :param rsc:
        :type rsc: float
        :param nitrate:
        :type nitrate: float
        :param nitrate_cl_ratio:
        :type nitrate_cl_ratio: float
        :param bicarbonate:
        :type bicarbonate: float
        :param block:
        :type block: str
        :param fluoride:
        :type fluoride: float
        :param na:
        :type na: float
        :param tss:
        :type tss: int
        :param silica:
        :type silica: str
        :param percent_error:
        :type percent_error: float
        :param sulphate:
        :type sulphate: float
        :param latitude:
        :type latitude: float
        :param b:
        :type b: str
        :param tot_anion:
        :type tot_anion: float
        :param sar:
        :type sar: float
        :param well_site:
        :type well_site: str
        :param longitude:
        :type longitude: float
        :param k:
        :type k: float
        :param district:
        :type district: str
        :param tot_fe:
        :type tot_fe: float
        :param aquifer:
        :type aquifer: str
        :param nitrate_nitrite:
        :type nitrate_nitrite: float
        :param ca:
        :type ca: float
        :param tot_alkalinity:
        :type tot_alkalinity: float
        :param tot_coliform:
        :type tot_coliform: str
        :param tds:
        :type tds: float
        :param ammonia:
        :type ammonia: str
        :param site_id:
        :type site_id: str
        :param phosphate:
        :type phosphate: float
        :param th:
        :type th: float
        :param percent_na:
        :type percent_na: float
        :param ph:
        :type ph: float
        :param turbidity:
        :type turbidity: float
        :param chloride:
        :type chloride: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            s__n_=s__n_,
            sampling_date=sampling_date,
            sulphide=sulphide,
            phenol_alkalinity=phenol_alkalinity,
            camg_ratio=camg_ratio,
            hydroxyl=hydroxyl,
            site_name=site_name,
            nacl_ratio=nacl_ratio,
            chlorophyll_a=chlorophyll_a,
            village_na=village_na,
            depth_of_w=depth_of_w,
            carbonate=carbonate,
            state_ut=state_ut,
            bod=bod,
            mg=mg,
            tehsil=tehsil,
            ec=ec,
            tot_cation=tot_cation,
            rsc=rsc,
            nitrate=nitrate,
            nitrate_cl_ratio=nitrate_cl_ratio,
            bicarbonate=bicarbonate,
            block=block,
            fluoride=fluoride,
            na=na,
            tss=tss,
            silica=silica,
            percent_error=percent_error,
            sulphate=sulphate,
            latitude=latitude,
            b=b,
            tot_anion=tot_anion,
            sar=sar,
            well_site=well_site,
            longitude=longitude,
            k=k,
            district=district,
            tot_fe=tot_fe,
            aquifer=aquifer,
            nitrate_nitrite=nitrate_nitrite,
            ca=ca,
            tot_alkalinity=tot_alkalinity,
            tot_coliform=tot_coliform,
            tds=tds,
            ammonia=ammonia,
            site_id=site_id,
            phosphate=phosphate,
            th=th,
            percent_na=percent_na,
            ph=ph,
            turbidity=turbidity,
            chloride=chloride,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_features_without_preload_content(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        s__n_: Optional[StrictInt] = None,
        sampling_date: Optional[StrictStr] = None,
        sulphide: Optional[Union[StrictFloat, StrictInt]] = None,
        phenol_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        camg_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        hydroxyl: Optional[StrictInt] = None,
        site_name: Optional[StrictStr] = None,
        nacl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        chlorophyll_a: Optional[StrictStr] = None,
        village_na: Optional[StrictStr] = None,
        depth_of_w: Optional[Union[StrictFloat, StrictInt]] = None,
        carbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        state_ut: Optional[StrictStr] = None,
        bod: Optional[StrictStr] = None,
        mg: Optional[Union[StrictFloat, StrictInt]] = None,
        tehsil: Optional[StrictStr] = None,
        ec: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_cation: Optional[Union[StrictFloat, StrictInt]] = None,
        rsc: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate: Optional[Union[StrictFloat, StrictInt]] = None,
        nitrate_cl_ratio: Optional[Union[StrictFloat, StrictInt]] = None,
        bicarbonate: Optional[Union[StrictFloat, StrictInt]] = None,
        block: Optional[StrictStr] = None,
        fluoride: Optional[Union[StrictFloat, StrictInt]] = None,
        na: Optional[Union[StrictFloat, StrictInt]] = None,
        tss: Optional[StrictInt] = None,
        silica: Optional[StrictStr] = None,
        percent_error: Optional[Union[StrictFloat, StrictInt]] = None,
        sulphate: Optional[Union[StrictFloat, StrictInt]] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        b: Optional[StrictStr] = None,
        tot_anion: Optional[Union[StrictFloat, StrictInt]] = None,
        sar: Optional[Union[StrictFloat, StrictInt]] = None,
        well_site: Optional[StrictStr] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        k: Optional[Union[StrictFloat, StrictInt]] = None,
        district: Optional[StrictStr] = None,
        tot_fe: Optional[Union[StrictFloat, StrictInt]] = None,
        aquifer: Optional[StrictStr] = None,
        nitrate_nitrite: Optional[Union[StrictFloat, StrictInt]] = None,
        ca: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_alkalinity: Optional[Union[StrictFloat, StrictInt]] = None,
        tot_coliform: Optional[StrictStr] = None,
        tds: Optional[Union[StrictFloat, StrictInt]] = None,
        ammonia: Optional[StrictStr] = None,
        site_id: Optional[StrictStr] = None,
        phosphate: Optional[Union[StrictFloat, StrictInt]] = None,
        th: Optional[Union[StrictFloat, StrictInt]] = None,
        percent_na: Optional[Union[StrictFloat, StrictInt]] = None,
        ph: Optional[Union[StrictFloat, StrictInt]] = None,
        turbidity: Optional[Union[StrictFloat, StrictInt]] = None,
        chloride: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get features from Point location of well with the ground water quality related attributes


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param s__n_:
        :type s__n_: int
        :param sampling_date:
        :type sampling_date: str
        :param sulphide:
        :type sulphide: float
        :param phenol_alkalinity:
        :type phenol_alkalinity: float
        :param camg_ratio:
        :type camg_ratio: float
        :param hydroxyl:
        :type hydroxyl: int
        :param site_name:
        :type site_name: str
        :param nacl_ratio:
        :type nacl_ratio: float
        :param chlorophyll_a:
        :type chlorophyll_a: str
        :param village_na:
        :type village_na: str
        :param depth_of_w:
        :type depth_of_w: float
        :param carbonate:
        :type carbonate: float
        :param state_ut:
        :type state_ut: str
        :param bod:
        :type bod: str
        :param mg:
        :type mg: float
        :param tehsil:
        :type tehsil: str
        :param ec:
        :type ec: float
        :param tot_cation:
        :type tot_cation: float
        :param rsc:
        :type rsc: float
        :param nitrate:
        :type nitrate: float
        :param nitrate_cl_ratio:
        :type nitrate_cl_ratio: float
        :param bicarbonate:
        :type bicarbonate: float
        :param block:
        :type block: str
        :param fluoride:
        :type fluoride: float
        :param na:
        :type na: float
        :param tss:
        :type tss: int
        :param silica:
        :type silica: str
        :param percent_error:
        :type percent_error: float
        :param sulphate:
        :type sulphate: float
        :param latitude:
        :type latitude: float
        :param b:
        :type b: str
        :param tot_anion:
        :type tot_anion: float
        :param sar:
        :type sar: float
        :param well_site:
        :type well_site: str
        :param longitude:
        :type longitude: float
        :param k:
        :type k: float
        :param district:
        :type district: str
        :param tot_fe:
        :type tot_fe: float
        :param aquifer:
        :type aquifer: str
        :param nitrate_nitrite:
        :type nitrate_nitrite: float
        :param ca:
        :type ca: float
        :param tot_alkalinity:
        :type tot_alkalinity: float
        :param tot_coliform:
        :type tot_coliform: str
        :param tds:
        :type tds: float
        :param ammonia:
        :type ammonia: str
        :param site_id:
        :type site_id: str
        :param phosphate:
        :type phosphate: float
        :param th:
        :type th: float
        :param percent_na:
        :type percent_na: float
        :param ph:
        :type ph: float
        :param turbidity:
        :type turbidity: float
        :param chloride:
        :type chloride: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            s__n_=s__n_,
            sampling_date=sampling_date,
            sulphide=sulphide,
            phenol_alkalinity=phenol_alkalinity,
            camg_ratio=camg_ratio,
            hydroxyl=hydroxyl,
            site_name=site_name,
            nacl_ratio=nacl_ratio,
            chlorophyll_a=chlorophyll_a,
            village_na=village_na,
            depth_of_w=depth_of_w,
            carbonate=carbonate,
            state_ut=state_ut,
            bod=bod,
            mg=mg,
            tehsil=tehsil,
            ec=ec,
            tot_cation=tot_cation,
            rsc=rsc,
            nitrate=nitrate,
            nitrate_cl_ratio=nitrate_cl_ratio,
            bicarbonate=bicarbonate,
            block=block,
            fluoride=fluoride,
            na=na,
            tss=tss,
            silica=silica,
            percent_error=percent_error,
            sulphate=sulphate,
            latitude=latitude,
            b=b,
            tot_anion=tot_anion,
            sar=sar,
            well_site=well_site,
            longitude=longitude,
            k=k,
            district=district,
            tot_fe=tot_fe,
            aquifer=aquifer,
            nitrate_nitrite=nitrate_nitrite,
            ca=ca,
            tot_alkalinity=tot_alkalinity,
            tot_coliform=tot_coliform,
            tds=tds,
            ammonia=ammonia,
            site_id=site_id,
            phosphate=phosphate,
            th=th,
            percent_na=percent_na,
            ph=ph,
            turbidity=turbidity,
            chloride=chloride,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_features_serialize(
        self,
        bbox_crs,
        crs,
        bbox,
        datetime,
        limit,
        offset,
        s__n_,
        sampling_date,
        sulphide,
        phenol_alkalinity,
        camg_ratio,
        hydroxyl,
        site_name,
        nacl_ratio,
        chlorophyll_a,
        village_na,
        depth_of_w,
        carbonate,
        state_ut,
        bod,
        mg,
        tehsil,
        ec,
        tot_cation,
        rsc,
        nitrate,
        nitrate_cl_ratio,
        bicarbonate,
        block,
        fluoride,
        na,
        tss,
        silica,
        percent_error,
        sulphate,
        latitude,
        b,
        tot_anion,
        sar,
        well_site,
        longitude,
        k,
        district,
        tot_fe,
        aquifer,
        nitrate_nitrite,
        ca,
        tot_alkalinity,
        tot_coliform,
        tds,
        ammonia,
        site_id,
        phosphate,
        th,
        percent_na,
        ph,
        turbidity,
        chloride,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'bbox': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bbox_crs is not None:
            
            _query_params.append(('bbox-crs', bbox_crs))
            
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        if bbox is not None:
            
            _query_params.append(('bbox', bbox))
            
        if datetime is not None:
            
            _query_params.append(('datetime', datetime))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if s__n_ is not None:
            
            _query_params.append(('S. N.', s__n_))
            
        if sampling_date is not None:
            
            _query_params.append(('SAMPLING_DATE', sampling_date))
            
        if sulphide is not None:
            
            _query_params.append(('SULPHIDE', sulphide))
            
        if phenol_alkalinity is not None:
            
            _query_params.append(('PHENOL_ALKALINITY', phenol_alkalinity))
            
        if camg_ratio is not None:
            
            _query_params.append(('CAMG_RATIO', camg_ratio))
            
        if hydroxyl is not None:
            
            _query_params.append(('HYDROXYL', hydroxyl))
            
        if site_name is not None:
            
            _query_params.append(('SITE_NAME', site_name))
            
        if nacl_ratio is not None:
            
            _query_params.append(('NACL_RATIO', nacl_ratio))
            
        if chlorophyll_a is not None:
            
            _query_params.append(('CHLOROPHYLL_A', chlorophyll_a))
            
        if village_na is not None:
            
            _query_params.append(('VILLAGE_NA', village_na))
            
        if depth_of_w is not None:
            
            _query_params.append(('DEPTH_OF_W', depth_of_w))
            
        if carbonate is not None:
            
            _query_params.append(('CARBONATE', carbonate))
            
        if state_ut is not None:
            
            _query_params.append(('STATE_UT', state_ut))
            
        if bod is not None:
            
            _query_params.append(('BOD', bod))
            
        if mg is not None:
            
            _query_params.append(('MG', mg))
            
        if tehsil is not None:
            
            _query_params.append(('TEHSIL', tehsil))
            
        if ec is not None:
            
            _query_params.append(('EC', ec))
            
        if tot_cation is not None:
            
            _query_params.append(('TOT_CATION', tot_cation))
            
        if rsc is not None:
            
            _query_params.append(('RSC', rsc))
            
        if nitrate is not None:
            
            _query_params.append(('NITRATE', nitrate))
            
        if nitrate_cl_ratio is not None:
            
            _query_params.append(('NITRATE_CL_RATIO', nitrate_cl_ratio))
            
        if bicarbonate is not None:
            
            _query_params.append(('BICARBONATE', bicarbonate))
            
        if block is not None:
            
            _query_params.append(('BLOCK', block))
            
        if fluoride is not None:
            
            _query_params.append(('FLUORIDE', fluoride))
            
        if na is not None:
            
            _query_params.append(('NA', na))
            
        if tss is not None:
            
            _query_params.append(('TSS', tss))
            
        if silica is not None:
            
            _query_params.append(('SILICA', silica))
            
        if percent_error is not None:
            
            _query_params.append(('PERCENT_ERROR', percent_error))
            
        if sulphate is not None:
            
            _query_params.append(('SULPHATE', sulphate))
            
        if latitude is not None:
            
            _query_params.append(('LATITUDE', latitude))
            
        if b is not None:
            
            _query_params.append(('B', b))
            
        if tot_anion is not None:
            
            _query_params.append(('TOT_ANION', tot_anion))
            
        if sar is not None:
            
            _query_params.append(('SAR', sar))
            
        if well_site is not None:
            
            _query_params.append(('WELL_SITE', well_site))
            
        if longitude is not None:
            
            _query_params.append(('LONGITUDE', longitude))
            
        if k is not None:
            
            _query_params.append(('K', k))
            
        if district is not None:
            
            _query_params.append(('DISTRICT', district))
            
        if tot_fe is not None:
            
            _query_params.append(('TOT_FE', tot_fe))
            
        if aquifer is not None:
            
            _query_params.append(('AQUIFER', aquifer))
            
        if nitrate_nitrite is not None:
            
            _query_params.append(('NITRATE_NITRITE', nitrate_nitrite))
            
        if ca is not None:
            
            _query_params.append(('CA', ca))
            
        if tot_alkalinity is not None:
            
            _query_params.append(('TOT_ALKALINITY', tot_alkalinity))
            
        if tot_coliform is not None:
            
            _query_params.append(('TOT_COLIFORM', tot_coliform))
            
        if tds is not None:
            
            _query_params.append(('TDS', tds))
            
        if ammonia is not None:
            
            _query_params.append(('AMMONIA', ammonia))
            
        if site_id is not None:
            
            _query_params.append(('SITE_ID', site_id))
            
        if phosphate is not None:
            
            _query_params.append(('PHOSPHATE', phosphate))
            
        if th is not None:
            
            _query_params.append(('TH', th))
            
        if percent_na is not None:
            
            _query_params.append(('PERCENT_NA', percent_na))
            
        if ph is not None:
            
            _query_params.append(('PH', ph))
            
        if turbidity is not None:
            
            _query_params.append(('TURBIDITY', turbidity))
            
        if chloride is not None:
            
            _query_params.append(('CHLORIDE', chloride))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/ed695b71-5b40-4a6c-a763-3159ba55b910/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_collection(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Metadata about Point location of well with the ground water quality related attributes


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_collection_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Metadata about Point location of well with the ground water quality related attributes


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_collection_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Metadata about Point location of well with the ground water quality related attributes


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_collection_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/ed695b71-5b40-4a6c-a763-3159ba55b910',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_feature(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureGeoJSON:
        """Get single feature from Point location of well with the ground water quality related attributes


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_feature_with_http_info(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureGeoJSON]:
        """Get single feature from Point location of well with the ground water quality related attributes


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_feature_without_preload_content(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single feature from Point location of well with the ground water quality related attributes


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_feature_serialize(
        self,
        feature_id,
        crs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['featureId'] = feature_id
        # process the query parameters
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/ed695b71-5b40-4a6c-a763-3159ba55b910/items/{featureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


