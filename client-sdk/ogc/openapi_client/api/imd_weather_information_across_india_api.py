# coding: utf-8

"""
    OGC Compliant DX Resource Server

    OGC compliant Features and Common API definitions. Includes Schema and Response Objects.   <a href='/stac/api'>STAC API Documentation</a>    <a href='/metering/api'>DX Metering API Documentation</a>

    The version of the OpenAPI document: 1.0.1
    Contact: info@iudx.org.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.collection import Collection
from openapi_client.models.feature_collection_geo_json import FeatureCollectionGeoJSON
from openapi_client.models.feature_geo_json import FeatureGeoJSON

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class IMDWeatherInformationAcrossIndiaApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_features(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        previous_day_relative_humidity_at_1730: Optional[StrictInt] = None,
        todays_forecast: Optional[StrictStr] = None,
        sunset_time: Optional[StrictStr] = None,
        day_4_forecast: Optional[StrictStr] = None,
        day_3_min_temp: Optional[StrictInt] = None,
        observation_date_time: Optional[StrictStr] = None,
        day_4_min_temp: Optional[StrictInt] = None,
        relative_humidity_at_1730: Optional[StrictStr] = None,
        day_4_max_temp: Optional[StrictInt] = None,
        today_min_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        today_min_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        day_6_forecast: Optional[StrictStr] = None,
        day_7_max_temp: Optional[StrictInt] = None,
        station_code: Optional[StrictStr] = None,
        day_6_min_temp: Optional[StrictInt] = None,
        moonset_time: Optional[StrictStr] = None,
        day_3_forecast: Optional[StrictStr] = None,
        day_2_max_temp: Optional[StrictInt] = None,
        day_2_min_temp: Optional[StrictInt] = None,
        day_5_max_temp: Optional[StrictInt] = None,
        day_5_forecast: Optional[StrictStr] = None,
        relative_humidity_at_0830: Optional[StrictInt] = None,
        day_5_min_temp: Optional[StrictInt] = None,
        todays_forecast_min_temp: Optional[StrictInt] = None,
        station_name: Optional[StrictStr] = None,
        day_2_forecast: Optional[StrictStr] = None,
        today_max_temp: Optional[StrictStr] = None,
        todays_forecast_max_temp: Optional[StrictInt] = None,
        past_24_hrs_rainfall: Optional[StrictStr] = None,
        sunrise_time: Optional[StrictStr] = None,
        moonrise_time: Optional[StrictStr] = None,
        day_7_min_temp: Optional[StrictInt] = None,
        day_3_max_temp: Optional[StrictInt] = None,
        today_max_departure_from_normal: Optional[StrictStr] = None,
        day_7_forecast: Optional[StrictStr] = None,
        day_6_max_temp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureCollectionGeoJSON:
        """Get features from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param previous_day_relative_humidity_at_1730:
        :type previous_day_relative_humidity_at_1730: int
        :param todays_forecast:
        :type todays_forecast: str
        :param sunset_time:
        :type sunset_time: str
        :param day_4_forecast:
        :type day_4_forecast: str
        :param day_3_min_temp:
        :type day_3_min_temp: int
        :param observation_date_time:
        :type observation_date_time: str
        :param day_4_min_temp:
        :type day_4_min_temp: int
        :param relative_humidity_at_1730:
        :type relative_humidity_at_1730: str
        :param day_4_max_temp:
        :type day_4_max_temp: int
        :param today_min_departure_from_normal:
        :type today_min_departure_from_normal: str
        :param previous_day_max_departure_from_normal:
        :type previous_day_max_departure_from_normal: str
        :param previous_day_max_temp:
        :type previous_day_max_temp: float
        :param today_min_temp:
        :type today_min_temp: float
        :param day_6_forecast:
        :type day_6_forecast: str
        :param day_7_max_temp:
        :type day_7_max_temp: int
        :param station_code:
        :type station_code: str
        :param day_6_min_temp:
        :type day_6_min_temp: int
        :param moonset_time:
        :type moonset_time: str
        :param day_3_forecast:
        :type day_3_forecast: str
        :param day_2_max_temp:
        :type day_2_max_temp: int
        :param day_2_min_temp:
        :type day_2_min_temp: int
        :param day_5_max_temp:
        :type day_5_max_temp: int
        :param day_5_forecast:
        :type day_5_forecast: str
        :param relative_humidity_at_0830:
        :type relative_humidity_at_0830: int
        :param day_5_min_temp:
        :type day_5_min_temp: int
        :param todays_forecast_min_temp:
        :type todays_forecast_min_temp: int
        :param station_name:
        :type station_name: str
        :param day_2_forecast:
        :type day_2_forecast: str
        :param today_max_temp:
        :type today_max_temp: str
        :param todays_forecast_max_temp:
        :type todays_forecast_max_temp: int
        :param past_24_hrs_rainfall:
        :type past_24_hrs_rainfall: str
        :param sunrise_time:
        :type sunrise_time: str
        :param moonrise_time:
        :type moonrise_time: str
        :param day_7_min_temp:
        :type day_7_min_temp: int
        :param day_3_max_temp:
        :type day_3_max_temp: int
        :param today_max_departure_from_normal:
        :type today_max_departure_from_normal: str
        :param day_7_forecast:
        :type day_7_forecast: str
        :param day_6_max_temp:
        :type day_6_max_temp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            previous_day_relative_humidity_at_1730=previous_day_relative_humidity_at_1730,
            todays_forecast=todays_forecast,
            sunset_time=sunset_time,
            day_4_forecast=day_4_forecast,
            day_3_min_temp=day_3_min_temp,
            observation_date_time=observation_date_time,
            day_4_min_temp=day_4_min_temp,
            relative_humidity_at_1730=relative_humidity_at_1730,
            day_4_max_temp=day_4_max_temp,
            today_min_departure_from_normal=today_min_departure_from_normal,
            previous_day_max_departure_from_normal=previous_day_max_departure_from_normal,
            previous_day_max_temp=previous_day_max_temp,
            today_min_temp=today_min_temp,
            day_6_forecast=day_6_forecast,
            day_7_max_temp=day_7_max_temp,
            station_code=station_code,
            day_6_min_temp=day_6_min_temp,
            moonset_time=moonset_time,
            day_3_forecast=day_3_forecast,
            day_2_max_temp=day_2_max_temp,
            day_2_min_temp=day_2_min_temp,
            day_5_max_temp=day_5_max_temp,
            day_5_forecast=day_5_forecast,
            relative_humidity_at_0830=relative_humidity_at_0830,
            day_5_min_temp=day_5_min_temp,
            todays_forecast_min_temp=todays_forecast_min_temp,
            station_name=station_name,
            day_2_forecast=day_2_forecast,
            today_max_temp=today_max_temp,
            todays_forecast_max_temp=todays_forecast_max_temp,
            past_24_hrs_rainfall=past_24_hrs_rainfall,
            sunrise_time=sunrise_time,
            moonrise_time=moonrise_time,
            day_7_min_temp=day_7_min_temp,
            day_3_max_temp=day_3_max_temp,
            today_max_departure_from_normal=today_max_departure_from_normal,
            day_7_forecast=day_7_forecast,
            day_6_max_temp=day_6_max_temp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_features_with_http_info(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        previous_day_relative_humidity_at_1730: Optional[StrictInt] = None,
        todays_forecast: Optional[StrictStr] = None,
        sunset_time: Optional[StrictStr] = None,
        day_4_forecast: Optional[StrictStr] = None,
        day_3_min_temp: Optional[StrictInt] = None,
        observation_date_time: Optional[StrictStr] = None,
        day_4_min_temp: Optional[StrictInt] = None,
        relative_humidity_at_1730: Optional[StrictStr] = None,
        day_4_max_temp: Optional[StrictInt] = None,
        today_min_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        today_min_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        day_6_forecast: Optional[StrictStr] = None,
        day_7_max_temp: Optional[StrictInt] = None,
        station_code: Optional[StrictStr] = None,
        day_6_min_temp: Optional[StrictInt] = None,
        moonset_time: Optional[StrictStr] = None,
        day_3_forecast: Optional[StrictStr] = None,
        day_2_max_temp: Optional[StrictInt] = None,
        day_2_min_temp: Optional[StrictInt] = None,
        day_5_max_temp: Optional[StrictInt] = None,
        day_5_forecast: Optional[StrictStr] = None,
        relative_humidity_at_0830: Optional[StrictInt] = None,
        day_5_min_temp: Optional[StrictInt] = None,
        todays_forecast_min_temp: Optional[StrictInt] = None,
        station_name: Optional[StrictStr] = None,
        day_2_forecast: Optional[StrictStr] = None,
        today_max_temp: Optional[StrictStr] = None,
        todays_forecast_max_temp: Optional[StrictInt] = None,
        past_24_hrs_rainfall: Optional[StrictStr] = None,
        sunrise_time: Optional[StrictStr] = None,
        moonrise_time: Optional[StrictStr] = None,
        day_7_min_temp: Optional[StrictInt] = None,
        day_3_max_temp: Optional[StrictInt] = None,
        today_max_departure_from_normal: Optional[StrictStr] = None,
        day_7_forecast: Optional[StrictStr] = None,
        day_6_max_temp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureCollectionGeoJSON]:
        """Get features from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param previous_day_relative_humidity_at_1730:
        :type previous_day_relative_humidity_at_1730: int
        :param todays_forecast:
        :type todays_forecast: str
        :param sunset_time:
        :type sunset_time: str
        :param day_4_forecast:
        :type day_4_forecast: str
        :param day_3_min_temp:
        :type day_3_min_temp: int
        :param observation_date_time:
        :type observation_date_time: str
        :param day_4_min_temp:
        :type day_4_min_temp: int
        :param relative_humidity_at_1730:
        :type relative_humidity_at_1730: str
        :param day_4_max_temp:
        :type day_4_max_temp: int
        :param today_min_departure_from_normal:
        :type today_min_departure_from_normal: str
        :param previous_day_max_departure_from_normal:
        :type previous_day_max_departure_from_normal: str
        :param previous_day_max_temp:
        :type previous_day_max_temp: float
        :param today_min_temp:
        :type today_min_temp: float
        :param day_6_forecast:
        :type day_6_forecast: str
        :param day_7_max_temp:
        :type day_7_max_temp: int
        :param station_code:
        :type station_code: str
        :param day_6_min_temp:
        :type day_6_min_temp: int
        :param moonset_time:
        :type moonset_time: str
        :param day_3_forecast:
        :type day_3_forecast: str
        :param day_2_max_temp:
        :type day_2_max_temp: int
        :param day_2_min_temp:
        :type day_2_min_temp: int
        :param day_5_max_temp:
        :type day_5_max_temp: int
        :param day_5_forecast:
        :type day_5_forecast: str
        :param relative_humidity_at_0830:
        :type relative_humidity_at_0830: int
        :param day_5_min_temp:
        :type day_5_min_temp: int
        :param todays_forecast_min_temp:
        :type todays_forecast_min_temp: int
        :param station_name:
        :type station_name: str
        :param day_2_forecast:
        :type day_2_forecast: str
        :param today_max_temp:
        :type today_max_temp: str
        :param todays_forecast_max_temp:
        :type todays_forecast_max_temp: int
        :param past_24_hrs_rainfall:
        :type past_24_hrs_rainfall: str
        :param sunrise_time:
        :type sunrise_time: str
        :param moonrise_time:
        :type moonrise_time: str
        :param day_7_min_temp:
        :type day_7_min_temp: int
        :param day_3_max_temp:
        :type day_3_max_temp: int
        :param today_max_departure_from_normal:
        :type today_max_departure_from_normal: str
        :param day_7_forecast:
        :type day_7_forecast: str
        :param day_6_max_temp:
        :type day_6_max_temp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            previous_day_relative_humidity_at_1730=previous_day_relative_humidity_at_1730,
            todays_forecast=todays_forecast,
            sunset_time=sunset_time,
            day_4_forecast=day_4_forecast,
            day_3_min_temp=day_3_min_temp,
            observation_date_time=observation_date_time,
            day_4_min_temp=day_4_min_temp,
            relative_humidity_at_1730=relative_humidity_at_1730,
            day_4_max_temp=day_4_max_temp,
            today_min_departure_from_normal=today_min_departure_from_normal,
            previous_day_max_departure_from_normal=previous_day_max_departure_from_normal,
            previous_day_max_temp=previous_day_max_temp,
            today_min_temp=today_min_temp,
            day_6_forecast=day_6_forecast,
            day_7_max_temp=day_7_max_temp,
            station_code=station_code,
            day_6_min_temp=day_6_min_temp,
            moonset_time=moonset_time,
            day_3_forecast=day_3_forecast,
            day_2_max_temp=day_2_max_temp,
            day_2_min_temp=day_2_min_temp,
            day_5_max_temp=day_5_max_temp,
            day_5_forecast=day_5_forecast,
            relative_humidity_at_0830=relative_humidity_at_0830,
            day_5_min_temp=day_5_min_temp,
            todays_forecast_min_temp=todays_forecast_min_temp,
            station_name=station_name,
            day_2_forecast=day_2_forecast,
            today_max_temp=today_max_temp,
            todays_forecast_max_temp=todays_forecast_max_temp,
            past_24_hrs_rainfall=past_24_hrs_rainfall,
            sunrise_time=sunrise_time,
            moonrise_time=moonrise_time,
            day_7_min_temp=day_7_min_temp,
            day_3_max_temp=day_3_max_temp,
            today_max_departure_from_normal=today_max_departure_from_normal,
            day_7_forecast=day_7_forecast,
            day_6_max_temp=day_6_max_temp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_features_without_preload_content(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        previous_day_relative_humidity_at_1730: Optional[StrictInt] = None,
        todays_forecast: Optional[StrictStr] = None,
        sunset_time: Optional[StrictStr] = None,
        day_4_forecast: Optional[StrictStr] = None,
        day_3_min_temp: Optional[StrictInt] = None,
        observation_date_time: Optional[StrictStr] = None,
        day_4_min_temp: Optional[StrictInt] = None,
        relative_humidity_at_1730: Optional[StrictStr] = None,
        day_4_max_temp: Optional[StrictInt] = None,
        today_min_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_departure_from_normal: Optional[StrictStr] = None,
        previous_day_max_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        today_min_temp: Optional[Union[StrictFloat, StrictInt]] = None,
        day_6_forecast: Optional[StrictStr] = None,
        day_7_max_temp: Optional[StrictInt] = None,
        station_code: Optional[StrictStr] = None,
        day_6_min_temp: Optional[StrictInt] = None,
        moonset_time: Optional[StrictStr] = None,
        day_3_forecast: Optional[StrictStr] = None,
        day_2_max_temp: Optional[StrictInt] = None,
        day_2_min_temp: Optional[StrictInt] = None,
        day_5_max_temp: Optional[StrictInt] = None,
        day_5_forecast: Optional[StrictStr] = None,
        relative_humidity_at_0830: Optional[StrictInt] = None,
        day_5_min_temp: Optional[StrictInt] = None,
        todays_forecast_min_temp: Optional[StrictInt] = None,
        station_name: Optional[StrictStr] = None,
        day_2_forecast: Optional[StrictStr] = None,
        today_max_temp: Optional[StrictStr] = None,
        todays_forecast_max_temp: Optional[StrictInt] = None,
        past_24_hrs_rainfall: Optional[StrictStr] = None,
        sunrise_time: Optional[StrictStr] = None,
        moonrise_time: Optional[StrictStr] = None,
        day_7_min_temp: Optional[StrictInt] = None,
        day_3_max_temp: Optional[StrictInt] = None,
        today_max_departure_from_normal: Optional[StrictStr] = None,
        day_7_forecast: Optional[StrictStr] = None,
        day_6_max_temp: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get features from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param previous_day_relative_humidity_at_1730:
        :type previous_day_relative_humidity_at_1730: int
        :param todays_forecast:
        :type todays_forecast: str
        :param sunset_time:
        :type sunset_time: str
        :param day_4_forecast:
        :type day_4_forecast: str
        :param day_3_min_temp:
        :type day_3_min_temp: int
        :param observation_date_time:
        :type observation_date_time: str
        :param day_4_min_temp:
        :type day_4_min_temp: int
        :param relative_humidity_at_1730:
        :type relative_humidity_at_1730: str
        :param day_4_max_temp:
        :type day_4_max_temp: int
        :param today_min_departure_from_normal:
        :type today_min_departure_from_normal: str
        :param previous_day_max_departure_from_normal:
        :type previous_day_max_departure_from_normal: str
        :param previous_day_max_temp:
        :type previous_day_max_temp: float
        :param today_min_temp:
        :type today_min_temp: float
        :param day_6_forecast:
        :type day_6_forecast: str
        :param day_7_max_temp:
        :type day_7_max_temp: int
        :param station_code:
        :type station_code: str
        :param day_6_min_temp:
        :type day_6_min_temp: int
        :param moonset_time:
        :type moonset_time: str
        :param day_3_forecast:
        :type day_3_forecast: str
        :param day_2_max_temp:
        :type day_2_max_temp: int
        :param day_2_min_temp:
        :type day_2_min_temp: int
        :param day_5_max_temp:
        :type day_5_max_temp: int
        :param day_5_forecast:
        :type day_5_forecast: str
        :param relative_humidity_at_0830:
        :type relative_humidity_at_0830: int
        :param day_5_min_temp:
        :type day_5_min_temp: int
        :param todays_forecast_min_temp:
        :type todays_forecast_min_temp: int
        :param station_name:
        :type station_name: str
        :param day_2_forecast:
        :type day_2_forecast: str
        :param today_max_temp:
        :type today_max_temp: str
        :param todays_forecast_max_temp:
        :type todays_forecast_max_temp: int
        :param past_24_hrs_rainfall:
        :type past_24_hrs_rainfall: str
        :param sunrise_time:
        :type sunrise_time: str
        :param moonrise_time:
        :type moonrise_time: str
        :param day_7_min_temp:
        :type day_7_min_temp: int
        :param day_3_max_temp:
        :type day_3_max_temp: int
        :param today_max_departure_from_normal:
        :type today_max_departure_from_normal: str
        :param day_7_forecast:
        :type day_7_forecast: str
        :param day_6_max_temp:
        :type day_6_max_temp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            previous_day_relative_humidity_at_1730=previous_day_relative_humidity_at_1730,
            todays_forecast=todays_forecast,
            sunset_time=sunset_time,
            day_4_forecast=day_4_forecast,
            day_3_min_temp=day_3_min_temp,
            observation_date_time=observation_date_time,
            day_4_min_temp=day_4_min_temp,
            relative_humidity_at_1730=relative_humidity_at_1730,
            day_4_max_temp=day_4_max_temp,
            today_min_departure_from_normal=today_min_departure_from_normal,
            previous_day_max_departure_from_normal=previous_day_max_departure_from_normal,
            previous_day_max_temp=previous_day_max_temp,
            today_min_temp=today_min_temp,
            day_6_forecast=day_6_forecast,
            day_7_max_temp=day_7_max_temp,
            station_code=station_code,
            day_6_min_temp=day_6_min_temp,
            moonset_time=moonset_time,
            day_3_forecast=day_3_forecast,
            day_2_max_temp=day_2_max_temp,
            day_2_min_temp=day_2_min_temp,
            day_5_max_temp=day_5_max_temp,
            day_5_forecast=day_5_forecast,
            relative_humidity_at_0830=relative_humidity_at_0830,
            day_5_min_temp=day_5_min_temp,
            todays_forecast_min_temp=todays_forecast_min_temp,
            station_name=station_name,
            day_2_forecast=day_2_forecast,
            today_max_temp=today_max_temp,
            todays_forecast_max_temp=todays_forecast_max_temp,
            past_24_hrs_rainfall=past_24_hrs_rainfall,
            sunrise_time=sunrise_time,
            moonrise_time=moonrise_time,
            day_7_min_temp=day_7_min_temp,
            day_3_max_temp=day_3_max_temp,
            today_max_departure_from_normal=today_max_departure_from_normal,
            day_7_forecast=day_7_forecast,
            day_6_max_temp=day_6_max_temp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_features_serialize(
        self,
        bbox_crs,
        crs,
        bbox,
        datetime,
        limit,
        offset,
        previous_day_relative_humidity_at_1730,
        todays_forecast,
        sunset_time,
        day_4_forecast,
        day_3_min_temp,
        observation_date_time,
        day_4_min_temp,
        relative_humidity_at_1730,
        day_4_max_temp,
        today_min_departure_from_normal,
        previous_day_max_departure_from_normal,
        previous_day_max_temp,
        today_min_temp,
        day_6_forecast,
        day_7_max_temp,
        station_code,
        day_6_min_temp,
        moonset_time,
        day_3_forecast,
        day_2_max_temp,
        day_2_min_temp,
        day_5_max_temp,
        day_5_forecast,
        relative_humidity_at_0830,
        day_5_min_temp,
        todays_forecast_min_temp,
        station_name,
        day_2_forecast,
        today_max_temp,
        todays_forecast_max_temp,
        past_24_hrs_rainfall,
        sunrise_time,
        moonrise_time,
        day_7_min_temp,
        day_3_max_temp,
        today_max_departure_from_normal,
        day_7_forecast,
        day_6_max_temp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'bbox': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bbox_crs is not None:
            
            _query_params.append(('bbox-crs', bbox_crs))
            
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        if bbox is not None:
            
            _query_params.append(('bbox', bbox))
            
        if datetime is not None:
            
            _query_params.append(('datetime', datetime))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if previous_day_relative_humidity_at_1730 is not None:
            
            _query_params.append(('Previous_Day_Relative_Humidity_at_1730', previous_day_relative_humidity_at_1730))
            
        if todays_forecast is not None:
            
            _query_params.append(('Todays_Forecast', todays_forecast))
            
        if sunset_time is not None:
            
            _query_params.append(('Sunset_time', sunset_time))
            
        if day_4_forecast is not None:
            
            _query_params.append(('Day_4_Forecast', day_4_forecast))
            
        if day_3_min_temp is not None:
            
            _query_params.append(('Day_3_Min_temp', day_3_min_temp))
            
        if observation_date_time is not None:
            
            _query_params.append(('observationDateTime', observation_date_time))
            
        if day_4_min_temp is not None:
            
            _query_params.append(('Day_4_Min_temp', day_4_min_temp))
            
        if relative_humidity_at_1730 is not None:
            
            _query_params.append(('Relative_Humidity_at_1730', relative_humidity_at_1730))
            
        if day_4_max_temp is not None:
            
            _query_params.append(('Day_4_Max_Temp', day_4_max_temp))
            
        if today_min_departure_from_normal is not None:
            
            _query_params.append(('Today_Min_Departure_from_Normal', today_min_departure_from_normal))
            
        if previous_day_max_departure_from_normal is not None:
            
            _query_params.append(('Previous_Day_Max_Departure_from_Normal', previous_day_max_departure_from_normal))
            
        if previous_day_max_temp is not None:
            
            _query_params.append(('Previous_Day_Max_temp', previous_day_max_temp))
            
        if today_min_temp is not None:
            
            _query_params.append(('Today_Min_temp', today_min_temp))
            
        if day_6_forecast is not None:
            
            _query_params.append(('Day_6_Forecast', day_6_forecast))
            
        if day_7_max_temp is not None:
            
            _query_params.append(('Day_7_Max_Temp', day_7_max_temp))
            
        if station_code is not None:
            
            _query_params.append(('Station_Code', station_code))
            
        if day_6_min_temp is not None:
            
            _query_params.append(('Day_6_Min_temp', day_6_min_temp))
            
        if moonset_time is not None:
            
            _query_params.append(('Moonset_time', moonset_time))
            
        if day_3_forecast is not None:
            
            _query_params.append(('Day_3_Forecast', day_3_forecast))
            
        if day_2_max_temp is not None:
            
            _query_params.append(('Day_2_Max_Temp', day_2_max_temp))
            
        if day_2_min_temp is not None:
            
            _query_params.append(('Day_2_Min_temp', day_2_min_temp))
            
        if day_5_max_temp is not None:
            
            _query_params.append(('Day_5_Max_Temp', day_5_max_temp))
            
        if day_5_forecast is not None:
            
            _query_params.append(('Day_5_Forecast', day_5_forecast))
            
        if relative_humidity_at_0830 is not None:
            
            _query_params.append(('Relative_Humidity_at_0830', relative_humidity_at_0830))
            
        if day_5_min_temp is not None:
            
            _query_params.append(('Day_5_Min_temp', day_5_min_temp))
            
        if todays_forecast_min_temp is not None:
            
            _query_params.append(('Todays_Forecast_Min_temp', todays_forecast_min_temp))
            
        if station_name is not None:
            
            _query_params.append(('Station_Name', station_name))
            
        if day_2_forecast is not None:
            
            _query_params.append(('Day_2_Forecast', day_2_forecast))
            
        if today_max_temp is not None:
            
            _query_params.append(('Today_Max_temp', today_max_temp))
            
        if todays_forecast_max_temp is not None:
            
            _query_params.append(('Todays_Forecast_Max_Temp', todays_forecast_max_temp))
            
        if past_24_hrs_rainfall is not None:
            
            _query_params.append(('Past_24_hrs_Rainfall', past_24_hrs_rainfall))
            
        if sunrise_time is not None:
            
            _query_params.append(('Sunrise_time', sunrise_time))
            
        if moonrise_time is not None:
            
            _query_params.append(('Moonrise_time', moonrise_time))
            
        if day_7_min_temp is not None:
            
            _query_params.append(('Day_7_Min_temp', day_7_min_temp))
            
        if day_3_max_temp is not None:
            
            _query_params.append(('Day_3_Max_Temp', day_3_max_temp))
            
        if today_max_departure_from_normal is not None:
            
            _query_params.append(('Today_Max_Departure_from_Normal', today_max_departure_from_normal))
            
        if day_7_forecast is not None:
            
            _query_params.append(('Day_7_Forecast', day_7_forecast))
            
        if day_6_max_temp is not None:
            
            _query_params.append(('Day_6_Max_Temp', day_6_max_temp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/180345b4-aaf9-41d2-bb97-cf652980fea8/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_collection(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Metadata about Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_collection_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Metadata about Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_collection_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Metadata about Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_collection_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/180345b4-aaf9-41d2-bb97-cf652980fea8',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_feature(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureGeoJSON:
        """Get single feature from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_feature_with_http_info(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureGeoJSON]:
        """Get single feature from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_feature_without_preload_content(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single feature from Weather info from stations across India recorded by Indian Meteorological Department (IMD) every hr


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_feature_serialize(
        self,
        feature_id,
        crs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['featureId'] = feature_id
        # process the query parameters
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/180345b4-aaf9-41d2-bb97-cf652980fea8/items/{featureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


