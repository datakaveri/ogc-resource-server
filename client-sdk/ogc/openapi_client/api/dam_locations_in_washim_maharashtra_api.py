# coding: utf-8

"""
    OGC Compliant IUDX Resource Server

    OGC compliant Features and Common API definitions. Includes Schema and Response Objects.

    The version of the OpenAPI document: 1.0.1
    Contact: info@iudx.org.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.collection import Collection
from openapi_client.models.feature_collection_geo_json import FeatureCollectionGeoJSON
from openapi_client.models.feature_geo_json import FeatureGeoJSON

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class DamLocationsInWashimMaharashtraApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_features(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        stcode: Optional[StrictStr] = None,
        spillway_l: Optional[StrictStr] = None,
        operating_: Optional[StrictStr] = None,
        river_name: Optional[StrictStr] = None,
        spillway_1: Optional[StrictStr] = None,
        spillway_3: Optional[StrictInt] = None,
        res_area_s: Optional[Union[StrictFloat, StrictInt]] = None,
        dam_perlia: Optional[StrictStr] = None,
        spillway_2: Optional[StrictStr] = None,
        canal_gate: Optional[StrictInt] = None,
        dtcode: Optional[StrictStr] = None,
        dam_length: Optional[StrictStr] = None,
        spillway_4: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_t: Optional[StrictStr] = None,
        max_height: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        seismic_zo: Optional[StrictStr] = None,
        subbasin: Optional[StrictStr] = None,
        spillway_c: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_g: Optional[StrictStr] = None,
        state: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        completion: Optional[StrictStr] = None,
        total_volu: Optional[StrictStr] = None,
        purpose: Optional[StrictStr] = None,
        basin: Optional[StrictStr] = None,
        design_flo: Optional[StrictStr] = None,
        bacode: Optional[StrictStr] = None,
        sbcode: Optional[StrictStr] = None,
        nearest_ci: Optional[StrictStr] = None,
        grs_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        dm_long: Optional[Union[StrictFloat, StrictInt]] = None,
        struct_typ: Optional[StrictStr] = None,
        dam_volume: Optional[Union[StrictFloat, StrictInt]] = None,
        strucode: Optional[StrictStr] = None,
        nrld_no: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        dm_lat: Optional[Union[StrictFloat, StrictInt]] = None,
        name: Optional[StrictStr] = None,
        eff_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        name_nrld_: Optional[StrictStr] = None,
        powerhouse: Optional[StrictInt] = None,
        status: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureCollectionGeoJSON:
        """Get features from Point features representing dam locations in Washim district, Maharashtra


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param stcode:
        :type stcode: str
        :param spillway_l:
        :type spillway_l: str
        :param operating_:
        :type operating_: str
        :param river_name:
        :type river_name: str
        :param spillway_1:
        :type spillway_1: str
        :param spillway_3:
        :type spillway_3: int
        :param res_area_s:
        :type res_area_s: float
        :param dam_perlia:
        :type dam_perlia: str
        :param spillway_2:
        :type spillway_2: str
        :param canal_gate:
        :type canal_gate: int
        :param dtcode:
        :type dtcode: str
        :param dam_length:
        :type dam_length: str
        :param spillway_4:
        :type spillway_4: float
        :param spillway_t:
        :type spillway_t: str
        :param max_height:
        :type max_height: str
        :param type:
        :type type: str
        :param seismic_zo:
        :type seismic_zo: str
        :param subbasin:
        :type subbasin: str
        :param spillway_c:
        :type spillway_c: float
        :param spillway_g:
        :type spillway_g: str
        :param state:
        :type state: str
        :param var_class:
        :type var_class: str
        :param completion:
        :type completion: str
        :param total_volu:
        :type total_volu: str
        :param purpose:
        :type purpose: str
        :param basin:
        :type basin: str
        :param design_flo:
        :type design_flo: str
        :param bacode:
        :type bacode: str
        :param sbcode:
        :type sbcode: str
        :param nearest_ci:
        :type nearest_ci: str
        :param grs_stor_c:
        :type grs_stor_c: float
        :param dm_long:
        :type dm_long: float
        :param struct_typ:
        :type struct_typ: str
        :param dam_volume:
        :type dam_volume: float
        :param strucode:
        :type strucode: str
        :param nrld_no:
        :type nrld_no: str
        :param district:
        :type district: str
        :param dm_lat:
        :type dm_lat: float
        :param name:
        :type name: str
        :param eff_stor_c:
        :type eff_stor_c: float
        :param name_nrld_:
        :type name_nrld_: str
        :param powerhouse:
        :type powerhouse: int
        :param status:
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            stcode=stcode,
            spillway_l=spillway_l,
            operating_=operating_,
            river_name=river_name,
            spillway_1=spillway_1,
            spillway_3=spillway_3,
            res_area_s=res_area_s,
            dam_perlia=dam_perlia,
            spillway_2=spillway_2,
            canal_gate=canal_gate,
            dtcode=dtcode,
            dam_length=dam_length,
            spillway_4=spillway_4,
            spillway_t=spillway_t,
            max_height=max_height,
            type=type,
            seismic_zo=seismic_zo,
            subbasin=subbasin,
            spillway_c=spillway_c,
            spillway_g=spillway_g,
            state=state,
            var_class=var_class,
            completion=completion,
            total_volu=total_volu,
            purpose=purpose,
            basin=basin,
            design_flo=design_flo,
            bacode=bacode,
            sbcode=sbcode,
            nearest_ci=nearest_ci,
            grs_stor_c=grs_stor_c,
            dm_long=dm_long,
            struct_typ=struct_typ,
            dam_volume=dam_volume,
            strucode=strucode,
            nrld_no=nrld_no,
            district=district,
            dm_lat=dm_lat,
            name=name,
            eff_stor_c=eff_stor_c,
            name_nrld_=name_nrld_,
            powerhouse=powerhouse,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_features_with_http_info(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        stcode: Optional[StrictStr] = None,
        spillway_l: Optional[StrictStr] = None,
        operating_: Optional[StrictStr] = None,
        river_name: Optional[StrictStr] = None,
        spillway_1: Optional[StrictStr] = None,
        spillway_3: Optional[StrictInt] = None,
        res_area_s: Optional[Union[StrictFloat, StrictInt]] = None,
        dam_perlia: Optional[StrictStr] = None,
        spillway_2: Optional[StrictStr] = None,
        canal_gate: Optional[StrictInt] = None,
        dtcode: Optional[StrictStr] = None,
        dam_length: Optional[StrictStr] = None,
        spillway_4: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_t: Optional[StrictStr] = None,
        max_height: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        seismic_zo: Optional[StrictStr] = None,
        subbasin: Optional[StrictStr] = None,
        spillway_c: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_g: Optional[StrictStr] = None,
        state: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        completion: Optional[StrictStr] = None,
        total_volu: Optional[StrictStr] = None,
        purpose: Optional[StrictStr] = None,
        basin: Optional[StrictStr] = None,
        design_flo: Optional[StrictStr] = None,
        bacode: Optional[StrictStr] = None,
        sbcode: Optional[StrictStr] = None,
        nearest_ci: Optional[StrictStr] = None,
        grs_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        dm_long: Optional[Union[StrictFloat, StrictInt]] = None,
        struct_typ: Optional[StrictStr] = None,
        dam_volume: Optional[Union[StrictFloat, StrictInt]] = None,
        strucode: Optional[StrictStr] = None,
        nrld_no: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        dm_lat: Optional[Union[StrictFloat, StrictInt]] = None,
        name: Optional[StrictStr] = None,
        eff_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        name_nrld_: Optional[StrictStr] = None,
        powerhouse: Optional[StrictInt] = None,
        status: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureCollectionGeoJSON]:
        """Get features from Point features representing dam locations in Washim district, Maharashtra


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param stcode:
        :type stcode: str
        :param spillway_l:
        :type spillway_l: str
        :param operating_:
        :type operating_: str
        :param river_name:
        :type river_name: str
        :param spillway_1:
        :type spillway_1: str
        :param spillway_3:
        :type spillway_3: int
        :param res_area_s:
        :type res_area_s: float
        :param dam_perlia:
        :type dam_perlia: str
        :param spillway_2:
        :type spillway_2: str
        :param canal_gate:
        :type canal_gate: int
        :param dtcode:
        :type dtcode: str
        :param dam_length:
        :type dam_length: str
        :param spillway_4:
        :type spillway_4: float
        :param spillway_t:
        :type spillway_t: str
        :param max_height:
        :type max_height: str
        :param type:
        :type type: str
        :param seismic_zo:
        :type seismic_zo: str
        :param subbasin:
        :type subbasin: str
        :param spillway_c:
        :type spillway_c: float
        :param spillway_g:
        :type spillway_g: str
        :param state:
        :type state: str
        :param var_class:
        :type var_class: str
        :param completion:
        :type completion: str
        :param total_volu:
        :type total_volu: str
        :param purpose:
        :type purpose: str
        :param basin:
        :type basin: str
        :param design_flo:
        :type design_flo: str
        :param bacode:
        :type bacode: str
        :param sbcode:
        :type sbcode: str
        :param nearest_ci:
        :type nearest_ci: str
        :param grs_stor_c:
        :type grs_stor_c: float
        :param dm_long:
        :type dm_long: float
        :param struct_typ:
        :type struct_typ: str
        :param dam_volume:
        :type dam_volume: float
        :param strucode:
        :type strucode: str
        :param nrld_no:
        :type nrld_no: str
        :param district:
        :type district: str
        :param dm_lat:
        :type dm_lat: float
        :param name:
        :type name: str
        :param eff_stor_c:
        :type eff_stor_c: float
        :param name_nrld_:
        :type name_nrld_: str
        :param powerhouse:
        :type powerhouse: int
        :param status:
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            stcode=stcode,
            spillway_l=spillway_l,
            operating_=operating_,
            river_name=river_name,
            spillway_1=spillway_1,
            spillway_3=spillway_3,
            res_area_s=res_area_s,
            dam_perlia=dam_perlia,
            spillway_2=spillway_2,
            canal_gate=canal_gate,
            dtcode=dtcode,
            dam_length=dam_length,
            spillway_4=spillway_4,
            spillway_t=spillway_t,
            max_height=max_height,
            type=type,
            seismic_zo=seismic_zo,
            subbasin=subbasin,
            spillway_c=spillway_c,
            spillway_g=spillway_g,
            state=state,
            var_class=var_class,
            completion=completion,
            total_volu=total_volu,
            purpose=purpose,
            basin=basin,
            design_flo=design_flo,
            bacode=bacode,
            sbcode=sbcode,
            nearest_ci=nearest_ci,
            grs_stor_c=grs_stor_c,
            dm_long=dm_long,
            struct_typ=struct_typ,
            dam_volume=dam_volume,
            strucode=strucode,
            nrld_no=nrld_no,
            district=district,
            dm_lat=dm_lat,
            name=name,
            eff_stor_c=eff_stor_c,
            name_nrld_=name_nrld_,
            powerhouse=powerhouse,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_features_without_preload_content(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        stcode: Optional[StrictStr] = None,
        spillway_l: Optional[StrictStr] = None,
        operating_: Optional[StrictStr] = None,
        river_name: Optional[StrictStr] = None,
        spillway_1: Optional[StrictStr] = None,
        spillway_3: Optional[StrictInt] = None,
        res_area_s: Optional[Union[StrictFloat, StrictInt]] = None,
        dam_perlia: Optional[StrictStr] = None,
        spillway_2: Optional[StrictStr] = None,
        canal_gate: Optional[StrictInt] = None,
        dtcode: Optional[StrictStr] = None,
        dam_length: Optional[StrictStr] = None,
        spillway_4: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_t: Optional[StrictStr] = None,
        max_height: Optional[StrictStr] = None,
        type: Optional[StrictStr] = None,
        seismic_zo: Optional[StrictStr] = None,
        subbasin: Optional[StrictStr] = None,
        spillway_c: Optional[Union[StrictFloat, StrictInt]] = None,
        spillway_g: Optional[StrictStr] = None,
        state: Optional[StrictStr] = None,
        var_class: Optional[StrictStr] = None,
        completion: Optional[StrictStr] = None,
        total_volu: Optional[StrictStr] = None,
        purpose: Optional[StrictStr] = None,
        basin: Optional[StrictStr] = None,
        design_flo: Optional[StrictStr] = None,
        bacode: Optional[StrictStr] = None,
        sbcode: Optional[StrictStr] = None,
        nearest_ci: Optional[StrictStr] = None,
        grs_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        dm_long: Optional[Union[StrictFloat, StrictInt]] = None,
        struct_typ: Optional[StrictStr] = None,
        dam_volume: Optional[Union[StrictFloat, StrictInt]] = None,
        strucode: Optional[StrictStr] = None,
        nrld_no: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        dm_lat: Optional[Union[StrictFloat, StrictInt]] = None,
        name: Optional[StrictStr] = None,
        eff_stor_c: Optional[Union[StrictFloat, StrictInt]] = None,
        name_nrld_: Optional[StrictStr] = None,
        powerhouse: Optional[StrictInt] = None,
        status: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get features from Point features representing dam locations in Washim district, Maharashtra


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param stcode:
        :type stcode: str
        :param spillway_l:
        :type spillway_l: str
        :param operating_:
        :type operating_: str
        :param river_name:
        :type river_name: str
        :param spillway_1:
        :type spillway_1: str
        :param spillway_3:
        :type spillway_3: int
        :param res_area_s:
        :type res_area_s: float
        :param dam_perlia:
        :type dam_perlia: str
        :param spillway_2:
        :type spillway_2: str
        :param canal_gate:
        :type canal_gate: int
        :param dtcode:
        :type dtcode: str
        :param dam_length:
        :type dam_length: str
        :param spillway_4:
        :type spillway_4: float
        :param spillway_t:
        :type spillway_t: str
        :param max_height:
        :type max_height: str
        :param type:
        :type type: str
        :param seismic_zo:
        :type seismic_zo: str
        :param subbasin:
        :type subbasin: str
        :param spillway_c:
        :type spillway_c: float
        :param spillway_g:
        :type spillway_g: str
        :param state:
        :type state: str
        :param var_class:
        :type var_class: str
        :param completion:
        :type completion: str
        :param total_volu:
        :type total_volu: str
        :param purpose:
        :type purpose: str
        :param basin:
        :type basin: str
        :param design_flo:
        :type design_flo: str
        :param bacode:
        :type bacode: str
        :param sbcode:
        :type sbcode: str
        :param nearest_ci:
        :type nearest_ci: str
        :param grs_stor_c:
        :type grs_stor_c: float
        :param dm_long:
        :type dm_long: float
        :param struct_typ:
        :type struct_typ: str
        :param dam_volume:
        :type dam_volume: float
        :param strucode:
        :type strucode: str
        :param nrld_no:
        :type nrld_no: str
        :param district:
        :type district: str
        :param dm_lat:
        :type dm_lat: float
        :param name:
        :type name: str
        :param eff_stor_c:
        :type eff_stor_c: float
        :param name_nrld_:
        :type name_nrld_: str
        :param powerhouse:
        :type powerhouse: int
        :param status:
        :type status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            stcode=stcode,
            spillway_l=spillway_l,
            operating_=operating_,
            river_name=river_name,
            spillway_1=spillway_1,
            spillway_3=spillway_3,
            res_area_s=res_area_s,
            dam_perlia=dam_perlia,
            spillway_2=spillway_2,
            canal_gate=canal_gate,
            dtcode=dtcode,
            dam_length=dam_length,
            spillway_4=spillway_4,
            spillway_t=spillway_t,
            max_height=max_height,
            type=type,
            seismic_zo=seismic_zo,
            subbasin=subbasin,
            spillway_c=spillway_c,
            spillway_g=spillway_g,
            state=state,
            var_class=var_class,
            completion=completion,
            total_volu=total_volu,
            purpose=purpose,
            basin=basin,
            design_flo=design_flo,
            bacode=bacode,
            sbcode=sbcode,
            nearest_ci=nearest_ci,
            grs_stor_c=grs_stor_c,
            dm_long=dm_long,
            struct_typ=struct_typ,
            dam_volume=dam_volume,
            strucode=strucode,
            nrld_no=nrld_no,
            district=district,
            dm_lat=dm_lat,
            name=name,
            eff_stor_c=eff_stor_c,
            name_nrld_=name_nrld_,
            powerhouse=powerhouse,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_features_serialize(
        self,
        bbox_crs,
        crs,
        bbox,
        datetime,
        limit,
        offset,
        stcode,
        spillway_l,
        operating_,
        river_name,
        spillway_1,
        spillway_3,
        res_area_s,
        dam_perlia,
        spillway_2,
        canal_gate,
        dtcode,
        dam_length,
        spillway_4,
        spillway_t,
        max_height,
        type,
        seismic_zo,
        subbasin,
        spillway_c,
        spillway_g,
        state,
        var_class,
        completion,
        total_volu,
        purpose,
        basin,
        design_flo,
        bacode,
        sbcode,
        nearest_ci,
        grs_stor_c,
        dm_long,
        struct_typ,
        dam_volume,
        strucode,
        nrld_no,
        district,
        dm_lat,
        name,
        eff_stor_c,
        name_nrld_,
        powerhouse,
        status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'bbox': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bbox_crs is not None:
            
            _query_params.append(('bbox-crs', bbox_crs))
            
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        if bbox is not None:
            
            _query_params.append(('bbox', bbox))
            
        if datetime is not None:
            
            _query_params.append(('datetime', datetime))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if stcode is not None:
            
            _query_params.append(('stcode', stcode))
            
        if spillway_l is not None:
            
            _query_params.append(('spillway_l', spillway_l))
            
        if operating_ is not None:
            
            _query_params.append(('operating_', operating_))
            
        if river_name is not None:
            
            _query_params.append(('river_name', river_name))
            
        if spillway_1 is not None:
            
            _query_params.append(('spillway_1', spillway_1))
            
        if spillway_3 is not None:
            
            _query_params.append(('spillway_3', spillway_3))
            
        if res_area_s is not None:
            
            _query_params.append(('res_area_s', res_area_s))
            
        if dam_perlia is not None:
            
            _query_params.append(('dam_perlia', dam_perlia))
            
        if spillway_2 is not None:
            
            _query_params.append(('spillway_2', spillway_2))
            
        if canal_gate is not None:
            
            _query_params.append(('canal_gate', canal_gate))
            
        if dtcode is not None:
            
            _query_params.append(('dtcode', dtcode))
            
        if dam_length is not None:
            
            _query_params.append(('dam_length', dam_length))
            
        if spillway_4 is not None:
            
            _query_params.append(('spillway_4', spillway_4))
            
        if spillway_t is not None:
            
            _query_params.append(('spillway_t', spillway_t))
            
        if max_height is not None:
            
            _query_params.append(('max_height', max_height))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if seismic_zo is not None:
            
            _query_params.append(('seismic_zo', seismic_zo))
            
        if subbasin is not None:
            
            _query_params.append(('subbasin', subbasin))
            
        if spillway_c is not None:
            
            _query_params.append(('spillway_c', spillway_c))
            
        if spillway_g is not None:
            
            _query_params.append(('spillway_g', spillway_g))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if var_class is not None:
            
            _query_params.append(('class', var_class))
            
        if completion is not None:
            
            _query_params.append(('completion', completion))
            
        if total_volu is not None:
            
            _query_params.append(('total_volu', total_volu))
            
        if purpose is not None:
            
            _query_params.append(('Purpose', purpose))
            
        if basin is not None:
            
            _query_params.append(('basin', basin))
            
        if design_flo is not None:
            
            _query_params.append(('design_flo', design_flo))
            
        if bacode is not None:
            
            _query_params.append(('bacode', bacode))
            
        if sbcode is not None:
            
            _query_params.append(('sbcode', sbcode))
            
        if nearest_ci is not None:
            
            _query_params.append(('nearest_ci', nearest_ci))
            
        if grs_stor_c is not None:
            
            _query_params.append(('grs_stor_c', grs_stor_c))
            
        if dm_long is not None:
            
            _query_params.append(('dm_long', dm_long))
            
        if struct_typ is not None:
            
            _query_params.append(('Struct_Typ', struct_typ))
            
        if dam_volume is not None:
            
            _query_params.append(('dam_volume', dam_volume))
            
        if strucode is not None:
            
            _query_params.append(('strucode', strucode))
            
        if nrld_no is not None:
            
            _query_params.append(('nrld_no', nrld_no))
            
        if district is not None:
            
            _query_params.append(('district', district))
            
        if dm_lat is not None:
            
            _query_params.append(('dm_lat', dm_lat))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if eff_stor_c is not None:
            
            _query_params.append(('eff_stor_c', eff_stor_c))
            
        if name_nrld_ is not None:
            
            _query_params.append(('name_nrld_', name_nrld_))
            
        if powerhouse is not None:
            
            _query_params.append(('powerhouse', powerhouse))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/7eac4fea-eb72-4809-ae5e-8b15b97749f0/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_collection(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Metadata about Point features representing dam locations in Washim district, Maharashtra


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_collection_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Metadata about Point features representing dam locations in Washim district, Maharashtra


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_collection_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Metadata about Point features representing dam locations in Washim district, Maharashtra


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_collection_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/7eac4fea-eb72-4809-ae5e-8b15b97749f0',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_feature(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureGeoJSON:
        """Get single feature from Point features representing dam locations in Washim district, Maharashtra


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_feature_with_http_info(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureGeoJSON]:
        """Get single feature from Point features representing dam locations in Washim district, Maharashtra


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_feature_without_preload_content(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single feature from Point features representing dam locations in Washim district, Maharashtra


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_feature_serialize(
        self,
        feature_id,
        crs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['featureId'] = feature_id
        # process the query parameters
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/7eac4fea-eb72-4809-ae5e-8b15b97749f0/items/{featureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


