# coding: utf-8

"""
    OGC Compliant DX Resource Server

    OGC compliant Features and Common API definitions. Includes Schema and Response Objects.   <a href='/stac/api'>STAC API Documentation</a>    <a href='/metering/api'>DX Metering API Documentation</a>

    The version of the OpenAPI document: 1.0.1
    Contact: info@iudx.org.in
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.collection import Collection
from openapi_client.models.feature_collection_geo_json import FeatureCollectionGeoJSON
from openapi_client.models.feature_geo_json import FeatureGeoJSON

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class HistoricalDailyRainfall19012023VaranasiUPApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_features(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        drf19: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        drf20: Optional[StrictStr] = None,
        drf21: Optional[StrictStr] = None,
        year: Optional[StrictStr] = None,
        drf04: Optional[StrictStr] = None,
        drf26: Optional[StrictStr] = None,
        drf05: Optional[StrictStr] = None,
        drf27: Optional[StrictStr] = None,
        drf06: Optional[StrictStr] = None,
        drf28: Optional[StrictStr] = None,
        drf07: Optional[StrictStr] = None,
        drf29: Optional[StrictStr] = None,
        drf22: Optional[StrictStr] = None,
        drf01: Optional[StrictStr] = None,
        drf23: Optional[StrictStr] = None,
        drf02: Optional[StrictStr] = None,
        drf24: Optional[StrictStr] = None,
        drf03: Optional[StrictStr] = None,
        drf25: Optional[StrictStr] = None,
        mn: Optional[StrictStr] = None,
        station: Optional[StrictStr] = None,
        drf08: Optional[StrictStr] = None,
        drf09: Optional[StrictStr] = None,
        drf30: Optional[StrictStr] = None,
        drf31: Optional[StrictStr] = None,
        drf10: Optional[StrictStr] = None,
        drf15: Optional[StrictStr] = None,
        drf16: Optional[StrictStr] = None,
        drf17: Optional[StrictStr] = None,
        drf18: Optional[StrictStr] = None,
        drf11: Optional[StrictStr] = None,
        drf12: Optional[StrictStr] = None,
        drf13: Optional[StrictStr] = None,
        drf14: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureCollectionGeoJSON:
        """Get features from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param drf19:
        :type drf19: str
        :param district:
        :type district: str
        :param drf20:
        :type drf20: str
        :param drf21:
        :type drf21: str
        :param year:
        :type year: str
        :param drf04:
        :type drf04: str
        :param drf26:
        :type drf26: str
        :param drf05:
        :type drf05: str
        :param drf27:
        :type drf27: str
        :param drf06:
        :type drf06: str
        :param drf28:
        :type drf28: str
        :param drf07:
        :type drf07: str
        :param drf29:
        :type drf29: str
        :param drf22:
        :type drf22: str
        :param drf01:
        :type drf01: str
        :param drf23:
        :type drf23: str
        :param drf02:
        :type drf02: str
        :param drf24:
        :type drf24: str
        :param drf03:
        :type drf03: str
        :param drf25:
        :type drf25: str
        :param mn:
        :type mn: str
        :param station:
        :type station: str
        :param drf08:
        :type drf08: str
        :param drf09:
        :type drf09: str
        :param drf30:
        :type drf30: str
        :param drf31:
        :type drf31: str
        :param drf10:
        :type drf10: str
        :param drf15:
        :type drf15: str
        :param drf16:
        :type drf16: str
        :param drf17:
        :type drf17: str
        :param drf18:
        :type drf18: str
        :param drf11:
        :type drf11: str
        :param drf12:
        :type drf12: str
        :param drf13:
        :type drf13: str
        :param drf14:
        :type drf14: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            drf19=drf19,
            district=district,
            drf20=drf20,
            drf21=drf21,
            year=year,
            drf04=drf04,
            drf26=drf26,
            drf05=drf05,
            drf27=drf27,
            drf06=drf06,
            drf28=drf28,
            drf07=drf07,
            drf29=drf29,
            drf22=drf22,
            drf01=drf01,
            drf23=drf23,
            drf02=drf02,
            drf24=drf24,
            drf03=drf03,
            drf25=drf25,
            mn=mn,
            station=station,
            drf08=drf08,
            drf09=drf09,
            drf30=drf30,
            drf31=drf31,
            drf10=drf10,
            drf15=drf15,
            drf16=drf16,
            drf17=drf17,
            drf18=drf18,
            drf11=drf11,
            drf12=drf12,
            drf13=drf13,
            drf14=drf14,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_features_with_http_info(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        drf19: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        drf20: Optional[StrictStr] = None,
        drf21: Optional[StrictStr] = None,
        year: Optional[StrictStr] = None,
        drf04: Optional[StrictStr] = None,
        drf26: Optional[StrictStr] = None,
        drf05: Optional[StrictStr] = None,
        drf27: Optional[StrictStr] = None,
        drf06: Optional[StrictStr] = None,
        drf28: Optional[StrictStr] = None,
        drf07: Optional[StrictStr] = None,
        drf29: Optional[StrictStr] = None,
        drf22: Optional[StrictStr] = None,
        drf01: Optional[StrictStr] = None,
        drf23: Optional[StrictStr] = None,
        drf02: Optional[StrictStr] = None,
        drf24: Optional[StrictStr] = None,
        drf03: Optional[StrictStr] = None,
        drf25: Optional[StrictStr] = None,
        mn: Optional[StrictStr] = None,
        station: Optional[StrictStr] = None,
        drf08: Optional[StrictStr] = None,
        drf09: Optional[StrictStr] = None,
        drf30: Optional[StrictStr] = None,
        drf31: Optional[StrictStr] = None,
        drf10: Optional[StrictStr] = None,
        drf15: Optional[StrictStr] = None,
        drf16: Optional[StrictStr] = None,
        drf17: Optional[StrictStr] = None,
        drf18: Optional[StrictStr] = None,
        drf11: Optional[StrictStr] = None,
        drf12: Optional[StrictStr] = None,
        drf13: Optional[StrictStr] = None,
        drf14: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureCollectionGeoJSON]:
        """Get features from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param drf19:
        :type drf19: str
        :param district:
        :type district: str
        :param drf20:
        :type drf20: str
        :param drf21:
        :type drf21: str
        :param year:
        :type year: str
        :param drf04:
        :type drf04: str
        :param drf26:
        :type drf26: str
        :param drf05:
        :type drf05: str
        :param drf27:
        :type drf27: str
        :param drf06:
        :type drf06: str
        :param drf28:
        :type drf28: str
        :param drf07:
        :type drf07: str
        :param drf29:
        :type drf29: str
        :param drf22:
        :type drf22: str
        :param drf01:
        :type drf01: str
        :param drf23:
        :type drf23: str
        :param drf02:
        :type drf02: str
        :param drf24:
        :type drf24: str
        :param drf03:
        :type drf03: str
        :param drf25:
        :type drf25: str
        :param mn:
        :type mn: str
        :param station:
        :type station: str
        :param drf08:
        :type drf08: str
        :param drf09:
        :type drf09: str
        :param drf30:
        :type drf30: str
        :param drf31:
        :type drf31: str
        :param drf10:
        :type drf10: str
        :param drf15:
        :type drf15: str
        :param drf16:
        :type drf16: str
        :param drf17:
        :type drf17: str
        :param drf18:
        :type drf18: str
        :param drf11:
        :type drf11: str
        :param drf12:
        :type drf12: str
        :param drf13:
        :type drf13: str
        :param drf14:
        :type drf14: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            drf19=drf19,
            district=district,
            drf20=drf20,
            drf21=drf21,
            year=year,
            drf04=drf04,
            drf26=drf26,
            drf05=drf05,
            drf27=drf27,
            drf06=drf06,
            drf28=drf28,
            drf07=drf07,
            drf29=drf29,
            drf22=drf22,
            drf01=drf01,
            drf23=drf23,
            drf02=drf02,
            drf24=drf24,
            drf03=drf03,
            drf25=drf25,
            mn=mn,
            station=station,
            drf08=drf08,
            drf09=drf09,
            drf30=drf30,
            drf31=drf31,
            drf10=drf10,
            drf15=drf15,
            drf16=drf16,
            drf17=drf17,
            drf18=drf18,
            drf11=drf11,
            drf12=drf12,
            drf13=drf13,
            drf14=drf14,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_features_without_preload_content(
        self,
        bbox_crs: Optional[StrictStr] = None,
        crs: Optional[StrictStr] = None,
        bbox: Annotated[Optional[Annotated[List[Union[StrictFloat, StrictInt]], Field(min_length=4, max_length=6)]], Field(description="Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.")] = None,
        datetime: Annotated[Optional[StrictStr], Field(description="Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.")] = None,
        limit: Optional[Annotated[int, Field(le=5000, strict=True, ge=1)]] = None,
        offset: Annotated[Optional[Annotated[int, Field(le=2000000, strict=True, ge=1)]], Field(description="OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.")] = None,
        drf19: Optional[StrictStr] = None,
        district: Optional[StrictStr] = None,
        drf20: Optional[StrictStr] = None,
        drf21: Optional[StrictStr] = None,
        year: Optional[StrictStr] = None,
        drf04: Optional[StrictStr] = None,
        drf26: Optional[StrictStr] = None,
        drf05: Optional[StrictStr] = None,
        drf27: Optional[StrictStr] = None,
        drf06: Optional[StrictStr] = None,
        drf28: Optional[StrictStr] = None,
        drf07: Optional[StrictStr] = None,
        drf29: Optional[StrictStr] = None,
        drf22: Optional[StrictStr] = None,
        drf01: Optional[StrictStr] = None,
        drf23: Optional[StrictStr] = None,
        drf02: Optional[StrictStr] = None,
        drf24: Optional[StrictStr] = None,
        drf03: Optional[StrictStr] = None,
        drf25: Optional[StrictStr] = None,
        mn: Optional[StrictStr] = None,
        station: Optional[StrictStr] = None,
        drf08: Optional[StrictStr] = None,
        drf09: Optional[StrictStr] = None,
        drf30: Optional[StrictStr] = None,
        drf31: Optional[StrictStr] = None,
        drf10: Optional[StrictStr] = None,
        drf15: Optional[StrictStr] = None,
        drf16: Optional[StrictStr] = None,
        drf17: Optional[StrictStr] = None,
        drf18: Optional[StrictStr] = None,
        drf11: Optional[StrictStr] = None,
        drf12: Optional[StrictStr] = None,
        drf13: Optional[StrictStr] = None,
        drf14: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get features from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param bbox_crs:
        :type bbox_crs: str
        :param crs:
        :type crs: str
        :param bbox: Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  If the value consists of four numbers, the coordinate reference system is WGS 84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  If the value consists of six numbers, the coordinate reference system is WGS 84 longitude/latitude/ellipsoidal height (http://www.opengis.net/def/crs/OGC/0/CRS84h) unless a different coordinate reference system is specified in the parameter `bbox-crs`.  The query parameter `bbox-crs` is specified in OGC API - Features - Part 2: Coordinate Reference Systems by Reference.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
        :type bbox: List[float]
        :param datetime: Either a date-time or an interval. Date and time expressions adhere to RFC 3339. Intervals may be bounded or half-bounded (double-dots at start or end).  Examples:  * A date-time: \"2018-02-12T23:20:50Z\" * A bounded interval: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" * Half-bounded intervals: \"2018-02-12T00:00:00Z/..\" or \"../2018-03-18T12:31:12Z\"  Only features that have a temporal property that intersects the value of `datetime` are selected.  If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
        :type datetime: str
        :param limit:
        :type limit: int
        :param offset: OGC Resource server also offers way to paginate the result for queries.  If a query returns large number of records then user can use additional parameters in query parameters to limit numbers of records  to be returned.  Minimum = 0. Maximum = 1000. Default = 10.
        :type offset: int
        :param drf19:
        :type drf19: str
        :param district:
        :type district: str
        :param drf20:
        :type drf20: str
        :param drf21:
        :type drf21: str
        :param year:
        :type year: str
        :param drf04:
        :type drf04: str
        :param drf26:
        :type drf26: str
        :param drf05:
        :type drf05: str
        :param drf27:
        :type drf27: str
        :param drf06:
        :type drf06: str
        :param drf28:
        :type drf28: str
        :param drf07:
        :type drf07: str
        :param drf29:
        :type drf29: str
        :param drf22:
        :type drf22: str
        :param drf01:
        :type drf01: str
        :param drf23:
        :type drf23: str
        :param drf02:
        :type drf02: str
        :param drf24:
        :type drf24: str
        :param drf03:
        :type drf03: str
        :param drf25:
        :type drf25: str
        :param mn:
        :type mn: str
        :param station:
        :type station: str
        :param drf08:
        :type drf08: str
        :param drf09:
        :type drf09: str
        :param drf30:
        :type drf30: str
        :param drf31:
        :type drf31: str
        :param drf10:
        :type drf10: str
        :param drf15:
        :type drf15: str
        :param drf16:
        :type drf16: str
        :param drf17:
        :type drf17: str
        :param drf18:
        :type drf18: str
        :param drf11:
        :type drf11: str
        :param drf12:
        :type drf12: str
        :param drf13:
        :type drf13: str
        :param drf14:
        :type drf14: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_features_serialize(
            bbox_crs=bbox_crs,
            crs=crs,
            bbox=bbox,
            datetime=datetime,
            limit=limit,
            offset=offset,
            drf19=drf19,
            district=district,
            drf20=drf20,
            drf21=drf21,
            year=year,
            drf04=drf04,
            drf26=drf26,
            drf05=drf05,
            drf27=drf27,
            drf06=drf06,
            drf28=drf28,
            drf07=drf07,
            drf29=drf29,
            drf22=drf22,
            drf01=drf01,
            drf23=drf23,
            drf02=drf02,
            drf24=drf24,
            drf03=drf03,
            drf25=drf25,
            mn=mn,
            station=station,
            drf08=drf08,
            drf09=drf09,
            drf30=drf30,
            drf31=drf31,
            drf10=drf10,
            drf15=drf15,
            drf16=drf16,
            drf17=drf17,
            drf18=drf18,
            drf11=drf11,
            drf12=drf12,
            drf13=drf13,
            drf14=drf14,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureCollectionGeoJSON",
            '400': "Exception400",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_features_serialize(
        self,
        bbox_crs,
        crs,
        bbox,
        datetime,
        limit,
        offset,
        drf19,
        district,
        drf20,
        drf21,
        year,
        drf04,
        drf26,
        drf05,
        drf27,
        drf06,
        drf28,
        drf07,
        drf29,
        drf22,
        drf01,
        drf23,
        drf02,
        drf24,
        drf03,
        drf25,
        mn,
        station,
        drf08,
        drf09,
        drf30,
        drf31,
        drf10,
        drf15,
        drf16,
        drf17,
        drf18,
        drf11,
        drf12,
        drf13,
        drf14,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'bbox': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bbox_crs is not None:
            
            _query_params.append(('bbox-crs', bbox_crs))
            
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        if bbox is not None:
            
            _query_params.append(('bbox', bbox))
            
        if datetime is not None:
            
            _query_params.append(('datetime', datetime))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if drf19 is not None:
            
            _query_params.append(('DRF19', drf19))
            
        if district is not None:
            
            _query_params.append(('DISTRICT', district))
            
        if drf20 is not None:
            
            _query_params.append(('DRF20', drf20))
            
        if drf21 is not None:
            
            _query_params.append(('DRF21', drf21))
            
        if year is not None:
            
            _query_params.append(('YEAR', year))
            
        if drf04 is not None:
            
            _query_params.append(('DRF04', drf04))
            
        if drf26 is not None:
            
            _query_params.append(('DRF26', drf26))
            
        if drf05 is not None:
            
            _query_params.append(('DRF05', drf05))
            
        if drf27 is not None:
            
            _query_params.append(('DRF27', drf27))
            
        if drf06 is not None:
            
            _query_params.append(('DRF06', drf06))
            
        if drf28 is not None:
            
            _query_params.append(('DRF28', drf28))
            
        if drf07 is not None:
            
            _query_params.append(('DRF07', drf07))
            
        if drf29 is not None:
            
            _query_params.append(('DRF29', drf29))
            
        if drf22 is not None:
            
            _query_params.append(('DRF22', drf22))
            
        if drf01 is not None:
            
            _query_params.append(('DRF01', drf01))
            
        if drf23 is not None:
            
            _query_params.append(('DRF23', drf23))
            
        if drf02 is not None:
            
            _query_params.append(('DRF02', drf02))
            
        if drf24 is not None:
            
            _query_params.append(('DRF24', drf24))
            
        if drf03 is not None:
            
            _query_params.append(('DRF03', drf03))
            
        if drf25 is not None:
            
            _query_params.append(('DRF25', drf25))
            
        if mn is not None:
            
            _query_params.append(('MN', mn))
            
        if station is not None:
            
            _query_params.append(('STATION', station))
            
        if drf08 is not None:
            
            _query_params.append(('DRF08', drf08))
            
        if drf09 is not None:
            
            _query_params.append(('DRF09', drf09))
            
        if drf30 is not None:
            
            _query_params.append(('DRF30', drf30))
            
        if drf31 is not None:
            
            _query_params.append(('DRF31', drf31))
            
        if drf10 is not None:
            
            _query_params.append(('DRF10', drf10))
            
        if drf15 is not None:
            
            _query_params.append(('DRF15', drf15))
            
        if drf16 is not None:
            
            _query_params.append(('DRF16', drf16))
            
        if drf17 is not None:
            
            _query_params.append(('DRF17', drf17))
            
        if drf18 is not None:
            
            _query_params.append(('DRF18', drf18))
            
        if drf11 is not None:
            
            _query_params.append(('DRF11', drf11))
            
        if drf12 is not None:
            
            _query_params.append(('DRF12', drf12))
            
        if drf13 is not None:
            
            _query_params.append(('DRF13', drf13))
            
        if drf14 is not None:
            
            _query_params.append(('DRF14', drf14))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/52c3b306-245d-478a-9b6b-892902a19b32/items',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_collection(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Collection:
        """Metadata about Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_collection_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Collection]:
        """Metadata about Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_collection_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Metadata about Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_collection_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Collection",
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_collection_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/52c3b306-245d-478a-9b6b-892902a19b32',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_specific_feature(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FeatureGeoJSON:
        """Get single feature from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_specific_feature_with_http_info(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FeatureGeoJSON]:
        """Get single feature from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_specific_feature_without_preload_content(
        self,
        feature_id: StrictInt,
        crs: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get single feature from Daily rainfall records 1901-2023 for seven weather stations located in Varanasi district, UP


        :param feature_id: (required)
        :type feature_id: int
        :param crs:
        :type crs: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_specific_feature_serialize(
            feature_id=feature_id,
            crs=crs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FeatureGeoJSON",
            '404': None,
            '500': "Exception500",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_specific_feature_serialize(
        self,
        feature_id,
        crs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if feature_id is not None:
            _path_params['featureId'] = feature_id
        # process the query parameters
        if crs is not None:
            
            _query_params.append(('crs', crs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/geo+json', 
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'DX-AAA-Token'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/collections/52c3b306-245d-478a-9b6b-892902a19b32/items/{featureId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


